# Generated by Django 5.2 on 2025-11-14
# Custom migration to add UUID primary key to PlantImage model
"""
Migration to swap PlantImage primary key from auto-incrementing 'id' to UUID.

⚠️ IMPORTANT: PostgreSQL Required ⚠️

This migration uses PostgreSQL-specific raw SQL commands (ALTER TABLE, DROP CONSTRAINT).
SQLite has limited ALTER TABLE support and cannot swap primary keys this way.

For Production (PostgreSQL):
    python manage.py migrate garden_calendar

For Development (SQLite):
    Option 1 - Fake the migration (if no PlantImage data exists):
        python manage.py migrate garden_calendar 0005 --fake
        rm db.sqlite3
        python manage.py migrate

    Option 2 - Skip this migration and use fresh database:
        rm db.sqlite3
        python manage.py migrate

Migration Steps:
1. Add UUID field as nullable (handles existing data)
2. Populate UUIDs for existing records (RunPython)
3. Make UUID non-nullable
4. Drop old primary key constraint (raw SQL - PostgreSQL only)
5. Add new primary key on UUID (raw SQL - PostgreSQL only)
6. Remove old 'id' field

Reversibility:
- Fully reversible with 'reverse_sql' defined
- Rolling back will restore 'id' as primary key
"""

from django.db import migrations, models
from psycopg2 import sql
import uuid


# Whitelist of allowed tables (defense in depth - SQL injection prevention)
ALLOWED_TABLES = {'garden_calendar_plantimage'}


def validate_table_name(table_name: str) -> str:
    """
    Validate table name against whitelist for SQL injection prevention.

    Pattern: docs/patterns/security/input-validation.md
    Defense in depth: Even though table name is hardcoded, whitelist validation
    provides additional safety layer per CLAUDE.md migration security pattern.
    """
    if table_name not in ALLOWED_TABLES:
        raise ValueError(f"[SECURITY] Table not in whitelist: {table_name}")
    return table_name


def generate_uuids_for_existing_images(apps, schema_editor):
    """
    Generate UUIDs for any existing PlantImage records.
    This function will be called during migration if there are existing records.
    """
    PlantImage = apps.get_model('garden_calendar', 'PlantImage')
    for image in PlantImage.objects.all():
        if not image.uuid:
            image.uuid = uuid.uuid4()
            image.save(update_fields=['uuid'])


class Migration(migrations.Migration):

    dependencies = [
        ('garden_calendar', '0004_add_carelog_uuid_and_fields'),
    ]

    operations = [
        # Step 1: Add UUID field as nullable first (to handle existing data)
        migrations.AddField(
            model_name='plantimage',
            name='uuid',
            field=models.UUIDField(
                default=uuid.uuid4,
                editable=False,
                unique=True,
                null=True,  # Temporarily nullable
                help_text="Unique identifier for secure references"
            ),
        ),

        # Step 2: Populate UUIDs for any existing records
        migrations.RunPython(
            generate_uuids_for_existing_images,
            reverse_code=migrations.RunPython.noop
        ),

        # Step 3: Make UUID non-nullable
        migrations.AlterField(
            model_name='plantimage',
            name='uuid',
            field=models.UUIDField(
                default=uuid.uuid4,
                editable=False,
                unique=True,
                help_text="Unique identifier for secure references"
            ),
        ),

        # Step 4: Drop primary key constraint from 'id' using raw SQL (PostgreSQL specific)
        # Pattern: CLAUDE.md Migration SQL Injection Prevention (psycopg2.sql.Identifier + whitelist)
        migrations.RunSQL(
            sql=[
                # Validate table name against whitelist (defense in depth)
                sql.SQL('ALTER TABLE {} DROP CONSTRAINT IF EXISTS {}_pkey CASCADE;').format(
                    sql.Identifier(validate_table_name('garden_calendar_plantimage')),
                    sql.Identifier(validate_table_name('garden_calendar_plantimage'))
                ),
                sql.SQL('ALTER TABLE {} ADD PRIMARY KEY (uuid);').format(
                    sql.Identifier(validate_table_name('garden_calendar_plantimage'))
                ),
            ],
            reverse_sql=[
                sql.SQL('ALTER TABLE {} DROP CONSTRAINT IF EXISTS {}_pkey CASCADE;').format(
                    sql.Identifier(validate_table_name('garden_calendar_plantimage')),
                    sql.Identifier(validate_table_name('garden_calendar_plantimage'))
                ),
                sql.SQL('ALTER TABLE {} ADD PRIMARY KEY (id);').format(
                    sql.Identifier(validate_table_name('garden_calendar_plantimage'))
                ),
            ]
        ),

        # Step 5: Remove old 'id' field entirely
        migrations.RemoveField(
            model_name='plantimage',
            name='id',
        ),
    ]
