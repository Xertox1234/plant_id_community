# Generated by Django 5.2.7 on 2025-11-11
"""
Recreate trending index with CONCURRENTLY for zero-downtime deployment.

This migration addresses TODO #006 (P1 priority) by ensuring the trending
analytics index is created with PostgreSQL's CONCURRENTLY option for
zero-downtime index creation in production.

Performance Impact:
- Query: "Most viewed posts in last 30 days"
- Without index: 5-10 seconds (1M row table scan)
- With index: <100ms (index scan)

Query Pattern:
```python
BlogPostView.objects.filter(
    viewed_at__gte=thirty_days_ago
).values('post').annotate(
    view_count=Count('id')
).order_by('-view_count')
```

Implementation Notes:
- Uses CONCURRENTLY for zero-downtime index creation
- Drops existing index created in migration 0011
- PostgreSQL-specific feature, gracefully degrades on SQLite (dev environment)
- Index size estimate: ~5-10MB for 100K views

Production Deployment:
- CONCURRENTLY avoids table locks during index creation
- Allows concurrent reads/writes during index build
- Takes longer than standard CREATE INDEX but no downtime
- Safe for production deployment

References:
- TODO #006: Missing Index - BlogPostView Trending Analytics
- PostgreSQL docs: https://www.postgresql.org/docs/current/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY
"""

from django.db import migrations, connection
from psycopg2 import sql


def create_trending_index_concurrently(apps, schema_editor):
    """
    Create trending analytics index with CONCURRENTLY option.

    Uses raw SQL for PostgreSQL CONCURRENTLY feature.
    SQLite (dev) will skip this operation gracefully.
    """
    # Only run on PostgreSQL (production)
    if connection.vendor != 'postgresql':
        print("⚠️  Skipping CONCURRENTLY index creation (not PostgreSQL)")
        return

    with connection.cursor() as cursor:
        # Step 1: Drop existing index from migration 0011 if it exists
        # Use IF EXISTS to avoid errors if already dropped
        cursor.execute("""
            DROP INDEX IF EXISTS blog_view_trending_idx;
        """)
        print("✅ Dropped existing blog_view_trending_idx index")

        # Step 2: Create index with CONCURRENTLY option
        # Note: CONCURRENTLY cannot run inside a transaction block
        # Django migrations auto-commit individual operations for PostgreSQL
        cursor.execute("""
            CREATE INDEX CONCURRENTLY blog_view_trending_idx
            ON blog_blogpostview (viewed_at, post_id);
        """)
        print("✅ Created blog_view_trending_idx with CONCURRENTLY (zero downtime)")


def drop_trending_index_concurrently(apps, schema_editor):
    """
    Reverse migration: drop the trending index.

    Uses CONCURRENTLY for rollback safety.
    """
    if connection.vendor != 'postgresql':
        print("⚠️  Skipping CONCURRENTLY index drop (not PostgreSQL)")
        return

    with connection.cursor() as cursor:
        # Drop with CONCURRENTLY for zero-downtime rollback
        cursor.execute("""
            DROP INDEX CONCURRENTLY IF EXISTS blog_view_trending_idx;
        """)
        print("✅ Dropped blog_view_trending_idx with CONCURRENTLY")


class Migration(migrations.Migration):

    # Mark as atomic=False to allow CONCURRENTLY operations
    # PostgreSQL requires CONCURRENTLY to run outside transaction blocks
    atomic = False

    dependencies = [
        ('blog', '0011_add_trending_index'),
    ]

    operations = [
        migrations.RunPython(
            create_trending_index_concurrently,
            reverse_code=drop_trending_index_concurrently,
        ),
    ]
