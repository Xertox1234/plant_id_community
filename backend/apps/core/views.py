"""
Core views for the application.

Includes CSRF token endpoint for SPA integration, React app view,
and CSP violation reporting endpoint (Issue #014).
"""

import logging
from django.http import JsonResponse
from django.middleware.csrf import get_token
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt
from django.views.generic import TemplateView
from django.conf import settings
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.response import Response

logger = logging.getLogger(__name__)


@require_http_methods(["GET"])
def csrf_token_view(request):
    """
    Provide CSRF token for JavaScript applications (Issue #144 fix).

    This endpoint allows SPAs to retrieve the CSRF token securely
    without reading it directly from the cookie (which would require
    CSRF_COOKIE_HTTPONLY = False).

    DEPRECATED: Use meta tag pattern (ReactAppView) instead.
    This endpoint is kept for backward compatibility.

    Usage in React:
    ```typescript
    const response = await fetch('/api/csrf/');
    const { csrfToken } = await response.json();
    // Use csrfToken in X-CSRFToken header
    ```

    Returns:
        JsonResponse: {"csrfToken": "abc123..."}
    """
    return JsonResponse({'csrfToken': get_token(request)})


class ReactAppView(TemplateView):
    """
    Serve React SPA with CSRF token in meta tag (Issue #013 fix - Django standard pattern).

    This view serves the React application through Django, which allows us to:
    1. Set CSRF_COOKIE_HTTPONLY = True (prevents XSS from stealing CSRF token)
    2. Inject CSRF token into meta tag for frontend to read
    3. Improve SEO with server-side rendering context

    Security Benefits:
    - CSRF cookie is HttpOnly (JavaScript cannot read it)
    - CSRF token accessible via meta tag (frontend can send in headers)
    - XSS attacks cannot steal CSRF token from cookie
    - Defense-in-depth: HttpOnly cookie + XSS prevention

    Template: templates/react_app.html
    Meta tag: <meta name="csrf-token" content="{{ csrf_token }}">

    Usage in React:
    ```typescript
    // Read from meta tag instead of cookie
    const meta = document.querySelector('meta[name="csrf-token"]');
    const token = meta ? meta.getAttribute('content') : null;
    ```
    """
    template_name = 'react_app.html'

    def get_context_data(self, **kwargs):
        """
        Add CSRF token and debug flag to template context.

        The CSRF token is automatically generated by Django's template
        engine when {{ csrf_token }} is used in the template.
        """
        context = super().get_context_data(**kwargs)

        # Ensure CSRF token is generated for this request
        get_token(self.request)

        # Pass DEBUG flag for conditional asset loading (dev vs production)
        context['debug'] = settings.DEBUG

        return context


@api_view(['POST'])
@permission_classes([AllowAny])
@csrf_exempt  # CSP reports are POST from browser, no CSRF token
def csp_report_view(request):
    """
    Receive and log Content Security Policy (CSP) violation reports (Issue #014).

    CSP violations occur when the browser blocks resource loading that violates
    the configured Content Security Policy directives. These reports help identify:
    - Unexpected inline scripts/styles (potential XSS)
    - Resources loaded from unauthorized domains
    - Policy misconfigurations affecting legitimate functionality

    Security Note:
    - @csrf_exempt required because browsers send CSP reports without CSRF tokens
    - AllowAny permission because reports come from unauthenticated page loads
    - Reports are JSON posted by the browser (not user-controlled)

    CSP Report Format (application/csp-report):
    {
        "csp-report": {
            "document-uri": "https://example.com/page",
            "violated-directive": "script-src 'self'",
            "blocked-uri": "https://evil.com/script.js",
            "source-file": "https://example.com/page",
            "line-number": 42,
            "column-number": 15
        }
    }

    Returns:
        204 No Content: Report successfully received
        400 Bad Request: Invalid report format
    """
    try:
        # CSP reports use Content-Type: application/csp-report
        # DRF's request.data handles both JSON and CSP report format
        report = request.data.get('csp-report', {})

        if not report:
            logger.warning("[CSP] Empty violation report received")
            return Response(status=400)

        # Extract violation details
        document_uri = report.get('document-uri', 'unknown')
        violated_directive = report.get('violated-directive', 'unknown')
        blocked_uri = report.get('blocked-uri', 'unknown')
        source_file = report.get('source-file', '')
        line_number = report.get('line-number', '')

        # Log the violation for monitoring and refinement
        logger.warning(
            f"[CSP] Violation detected: "
            f"directive='{violated_directive}', "
            f"blocked='{blocked_uri}', "
            f"document='{document_uri}', "
            f"source={source_file}:{line_number}"
        )

        # Optional: Store violations in database for analysis dashboard
        # CSPViolation.objects.create(
        #     document_uri=document_uri,
        #     violated_directive=violated_directive,
        #     blocked_uri=blocked_uri,
        #     source_file=source_file,
        #     line_number=line_number,
        #     user_agent=request.META.get('HTTP_USER_AGENT', ''),
        #     ip_address=request.META.get('REMOTE_ADDR', ''),
        # )

        return Response(status=204)  # 204 No Content (success, no response body)

    except Exception as e:
        logger.error(f"[CSP] Report parsing error: {str(e)}")
        return Response(status=400)
